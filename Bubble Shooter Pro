<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Retro Bubble Shooter Pro - Single File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg1: #050816;
      --bg2: #0b1020;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --accent-strong: #22d3ee;
      --danger: #f97373;
      --panel: rgba(15, 23, 42, 0.85);
      --panel-soft: rgba(15, 23, 42, 0.6);
      --border-soft: rgba(148, 163, 184, 0.4);
      --text-main: #e5e7eb;
      --text-sub: #9ca3af;
      --shadow-soft: 0 18px 40px rgba(15, 23, 42, 0.9);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      color: var(--text-main);
      background: radial-gradient(circle at top, #1f2937 0, #020617 50%, #020617 100%);
      overscroll-behavior: none;
      touch-action: none;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .app-shell {
      width: 100%;
      max-width: 420px;
      padding: 16px;
    }

    .chrome {
      position: relative;
      border-radius: 24px;
      padding: 18px 16px 20px;
      background: linear-gradient(145deg, rgba(15,23,42,0.98), rgba(15,23,42,0.92));
      border: 1px solid rgba(148, 163, 184, 0.45);
      box-shadow: var(--shadow-soft);
      overflow: hidden;
    }

    .chrome::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at 0% 0%, rgba(56,189,248,0.12), transparent 60%),
        radial-gradient(circle at 100% 20%, rgba(236,72,153,0.14), transparent 60%),
        radial-gradient(circle at 50% 120%, rgba(94,234,212,0.18), transparent 60%);
      opacity: 0.9;
      pointer-events: none;
      z-index: -1;
    }

    .chrome-inner {
      position: relative;
      border-radius: 16px;
      padding: 16px 14px 14px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(15,23,42,0.96));
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .app-header {
      text-align: center;
      margin-bottom: 10px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: radial-gradient(circle at 0% 0%, rgba(56,189,248,0.16), transparent 60%);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: #a5b4fc;
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.9);
    }

    .title {
      margin-top: 7px;
      font-size: 21px;
      font-weight: 800;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #e5e5f5;
      text-shadow:
        0 0 10px rgba(56,189,248,0.7),
        0 0 30px rgba(56,189,248,0.4);
    }

    .title span {
      color: #facc15;
    }

    .subtitle {
      margin-top: 3px;
      font-size: 11px;
      color: var(--text-sub);
    }

    .top-panel {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      margin-top: 12px;
    }

    .score-card {
      flex: 1;
      padding: 10px 10px 9px;
      border-radius: 12px;
      border: 1px solid var(--border-soft);
      background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(15,23,42,0.72));
    }

    .score-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: #64748b;
      margin-bottom: 2px;
    }

    .score-value {
      font-size: 22px;
      font-weight: 700;
      color: #fbbf24;
    }

    .score-sub {
      font-size: 10px;
      color: #9ca3af;
      margin-top: 2px;
    }

    .status-card {
      width: 110px;
      padding: 9px 10px 8px;
      border-radius: 12px;
      border: 1px solid rgba(94, 234, 212, 0.35);
      background: radial-gradient(circle at 0 0, rgba(56,189,248,0.24), rgba(15,23,42,0.9));
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 4px;
    }

    .status-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      color: #a5b4fc;
    }

    .status-value {
      font-size: 12px;
      font-weight: 600;
    }

    .status-value.ready {
      color: #38bdf8;
    }

    .status-value.playing {
      color: #22c55e;
    }

    .status-value.over {
      color: #f97373;
    }

    .status-badge-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .badge {
      padding: 3px 7px 3px;
      border-radius: 999px;
      border: 1px solid rgba(56, 189, 248, 0.5);
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #bae6fd;
      background: radial-gradient(circle at 0 0, rgba(59,130,246,0.25), rgba(15,23,42,0.9));
    }

    .badge-danger {
      border-color: rgba(248, 113, 113, 0.9);
      color: #fecaca;
      background: radial-gradient(circle at 0 0, rgba(248,113,113,0.25), rgba(15,23,42,0.95));
    }

    .badge-dot-row {
      display: flex;
      gap: 3px;
    }

    .badge-dot {
      width: 4px;
      height: 4px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.8);
    }

    .badge-dot.active {
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
    }

    .game-shell {
      margin-top: 14px;
      border-radius: 18px;
      padding: 10px 8px 10px;
      background: radial-gradient(circle at top, rgba(17,24,39,0.95), rgba(15,23,42,0.9));
      border: 1px solid rgba(15, 23, 42, 0.8);
      box-shadow: inset 0 0 0 1px rgba(15,23,42,0.85);
    }

    .game-inner {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      background: radial-gradient(circle at top, #020617, #020617 65%, #0f172a 100%);
      border: 1px solid rgba(15,23,42,0.9);
    }

    .scanline-overlay {
      pointer-events: none;
      position: absolute;
      inset: 0;
      background-image: linear-gradient(
        to bottom,
        rgba(15,23,42,0.9) 0px,
        rgba(15,23,42,0.4) 1px,
        transparent 2px,
        transparent 3px
      );
      opacity: 0.22;
      mix-blend-mode: soft-light;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: auto;
      max-height: 65vh;
      touch-action: none;
      cursor: crosshair;
    }

    .bottom-panel {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-top: 9px;
    }

    .btn {
      border: none;
      outline: none;
      cursor: pointer;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: transform 0.08s ease, box-shadow 0.12s ease,
        background 0.12s ease, opacity 0.12s ease;
    }

    .btn:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: none;
    }

    .btn-primary {
      flex: 1.1;
      background: radial-gradient(circle at 0 0, #22d3ee, #0ea5e9);
      color: #0b1120;
      box-shadow:
        0 10px 25px rgba(8,47,73,0.9),
        0 0 18px rgba(45,212,191,0.6);
      border: 1px solid rgba(34, 211, 238, 0.9);
    }

    .btn-primary[disabled] {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
    }

    .btn-secondary {
      flex: 0.9;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: #e5e7eb;
      box-shadow: 0 10px 30px rgba(15,23,42,0.8);
    }

    .btn-secondary.on {
      border-color: rgba(34, 197, 94, 0.9);
      color: #bbf7d0;
      box-shadow: 0 0 18px rgba(34,197,94,0.7);
    }

    .btn-icon {
      font-size: 13px;
    }

    .hint {
      margin-top: 8px;
      font-size: 11px;
      line-height: 1.35;
      color: var(--text-sub);
      text-align: center;
    }

    .hint span {
      color: #e5e7eb;
    }

    .game-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .overlay-panel {
      pointer-events: auto;
      min-width: 72%;
      max-width: 90%;
      border-radius: 16px;
      padding: 14px 12px 12px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.96), rgba(15,23,42,0.98));
      border: 1px solid rgba(248, 250, 252, 0.06);
      box-shadow:
        0 18px 45px rgba(15,23,42,0.95),
        0 0 30px rgba(56,189,248,0.45);
      text-align: center;
    }

    .overlay-title {
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #fee2e2;
      margin-bottom: 4px;
    }

    .overlay-sub {
      font-size: 11px;
      color: #cbd5f5;
      margin-bottom: 6px;
    }

    .overlay-metrics {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      margin-top: 8px;
      margin-bottom: 10px;
    }

    .overlay-metric {
      flex: 1;
      border-radius: 10px;
      padding: 6px 6px 5px;
      background: radial-gradient(circle at 0 0, rgba(56,189,248,0.16), rgba(15,23,42,0.96));
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .overlay-metric-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #94a3b8;
      margin-bottom: 2px;
    }

    .overlay-metric-value {
      font-size: 14px;
      font-weight: 600;
      color: #fbbf24;
    }

    .overlay-metric-sub {
      font-size: 9px;
      color: #9ca3af;
      margin-top: 1px;
    }

    @media (max-width: 480px) {
      .chrome {
        border-radius: 20px;
        padding: 14px 12px 16px;
      }
      .chrome-inner {
        padding: 12px 10px 10px;
      }
      .title {
        font-size: 18px;
      }
      .score-value {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="chrome">
      <div class="chrome-inner">
        <header class="app-header">
          <div class="pill">
            <span class="pill-dot"></span>
            RETRO ARCADE AI BUILD
          </div>
          <div class="title">
            BUBBLE <span>SHOOTER</span> PRO
          </div>
          <div class="subtitle">
            Tap or click to aim. Match 3+ bubbles to pop. Keep the wall away from the bottom line.
          </div>
        </header>

        <section class="top-panel">
          <div class="score-card">
            <div class="score-label">Score</div>
            <div class="score-value" id="scoreValue">0</div>
            <div class="score-sub">
              High score: <span id="highScoreValue">0</span>
            </div>
          </div>

          <div class="status-card">
            <div class="status-label">Game State</div>
            <div id="statusValue" class="status-value ready">Ready</div>
            <div class="status-badge-row">
              <div id="pressureBadge" class="badge">
                CHILL ZONE
              </div>
              <div class="badge-dot-row">
                <div class="badge-dot active"></div>
                <div class="badge-dot"></div>
                <div class="badge-dot"></div>
              </div>
            </div>
          </div>
        </section>

        <section class="game-shell">
          <div class="game-inner">
            <canvas id="gameCanvas" width="360" height="540"></canvas>
            <div class="scanline-overlay"></div>
            <div class="game-overlay" id="overlay" style="display:none;">
              <div class="overlay-panel">
                <div class="overlay-title" id="overlayTitle">GAME OVER</div>
                <div class="overlay-sub" id="overlaySubtitle">
                  The bubble wall breached the safety line.
                </div>
                <div class="overlay-metrics">
                  <div class="overlay-metric">
                    <div class="overlay-metric-label">Score</div>
                    <div class="overlay-metric-value" id="overlayScore">0</div>
                    <div class="overlay-metric-sub">This run</div>
                  </div>
                  <div class="overlay-metric">
                    <div class="overlay-metric-label">High Score</div>
                    <div class="overlay-metric-value" id="overlayHighScore">0</div>
                    <div class="overlay-metric-sub">Best ever</div>
                  </div>
                </div>
                <button class="btn btn-primary" id="btnTryAgain">
                  <span class="btn-icon">‚Üª</span> TRY AGAIN
                </button>
              </div>
            </div>
          </div>

          <div class="bottom-panel">
            <button class="btn btn-primary" id="btnStart">
              <span class="btn-icon">‚ñ∂</span> START
            </button>
            <button class="btn btn-secondary" id="btnMute">
              <span class="btn-icon">üîä</span> SOUND
            </button>
          </div>

          <p class="hint">
            <span>Tip:</span> drag or tap in the arena to aim your shot. Bounce off walls for trick shots.
          </p>
        </section>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Retro Bubble Shooter Logic
    // Vanilla JS, Single-File
    // =========================

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('scoreValue');
    const highScoreEl = document.getElementById('highScoreValue');
    const statusEl = document.getElementById('statusValue');
    const pressureBadgeEl = document.getElementById('pressureBadge');
    const overlayEl = document.getElementById('overlay');
    const overlayTitleEl = document.getElementById('overlayTitle');
    const overlaySubtitleEl = document.getElementById('overlaySubtitle');
    const overlayScoreEl = document.getElementById('overlayScore');
    const overlayHighScoreEl = document.getElementById('overlayHighScore');

    const btnStart = document.getElementById('btnStart');
    const btnMute = document.getElementById('btnMute');
    const btnTryAgain = document.getElementById('btnTryAgain');

    const W = canvas.width;
    const H = canvas.height;

    // Bubble grid config
    const BUBBLE_RADIUS = 14;
    const COLS = 12;
    const ROW_HEIGHT = BUBBLE_RADIUS * Math.sqrt(3); // hex packing
    const COLORS = ['#38bdf8', '#22c55e', '#f97316', '#e879f9', '#facc15', '#f97373'];

    const SHOOTER_Y = H - 40;
    const SHOOTER_X = W / 2;
    const SHOOT_SPEED = 340;

    const MAX_ROWS_VISIBLE = Math.floor((H - 80) / ROW_HEIGHT);

    // Game state
    let grid = [];          // 2D array of bubbles or null
    let currentBubble = null;
    let nextColor = randomColor();
    let isShooting = false;
    let score = 0;
    let highScore = 0;
    let isPlaying = false;
    let isGameOver = false;
    let lastTime = 0;
    let shotsSinceShift = 0;

    let muted = false;

    // ============ Sound system (simple, oscillator-based) ============
    function playTone(freq, duration, type = 'sine', volume = 0.15) {
      if (muted || typeof AudioContext === 'undefined') return;
      const ctx = new AudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + duration);
      osc.onended = () => ctx.close();
    }

    function playShootSound() {
      playTone(420, 0.05, 'square', 0.17);
    }

    function playPopSound() {
      playTone(740, 0.08, 'square', 0.14);
    }

    function playWallShiftSound() {
      playTone(180, 0.12, 'square', 0.18);
    }

    function playGameOverSound() {
      playTone(110, 0.3, 'sawtooth', 0.18);
    }

    // ================== Utilities ==================
    function randomColor() {
      return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    function loadHighScore() {
      try {
        const v = localStorage.getItem('retroBubbleHighScore_singlefile');
        if (v) highScore = parseInt(v, 10) || 0;
      } catch (_) {
        highScore = 0;
      }
      highScoreEl.textContent = highScore;
    }

    function saveHighScore() {
      try {
        localStorage.setItem('retroBubbleHighScore_singlefile', String(highScore));
      } catch (_) {}
    }

    function setStatus(state) {
      if (state === 'ready') {
        statusEl.textContent = 'Ready';
        statusEl.className = 'status-value ready';
        pressureBadgeEl.textContent = 'CHILL ZONE';
        pressureBadgeEl.className = 'badge';
      } else if (state === 'playing') {
        statusEl.textContent = 'Playing';
        statusEl.className = 'status-value playing';
      } else if (state === 'danger') {
        statusEl.textContent = 'Danger Zone';
        statusEl.className = 'status-value playing';
        pressureBadgeEl.textContent = 'DANGER ZONE';
        pressureBadgeEl.className = 'badge badge-danger';
      } else if (state === 'over') {
        statusEl.textContent = 'Game Over';
        statusEl.className = 'status-value over';
        pressureBadgeEl.textContent = 'WALL BREACHED';
        pressureBadgeEl.className = 'badge badge-danger';
      }
    }

    function resetGrid() {
      grid = [];
      const startRows = 6;
      for (let r = 0; r < startRows; r++) {
        const row = [];
        const offset = (r % 2 === 0) ? 0 : 0.5;
        for (let c = 0; c < COLS; c++) {
          if (Math.random() < 0.88) {
            const x = (c + offset) * (BUBBLE_RADIUS * 2) + BUBBLE_RADIUS;
            const y = BUBBLE_RADIUS + r * ROW_HEIGHT;
            row[c] = {
              r, c, x, y,
              color: randomColor()
            };
          } else {
            row[c] = null;
          }
        }
        grid.push(row);
      }
    }

    function createCurrentBubble() {
      currentBubble = {
        x: SHOOTER_X,
        y: SHOOTER_Y,
        vx: 0,
        vy: 0,
        color: nextColor,
        moving: false
      };
      nextColor = randomColor();
    }

    function startShot(targetX, targetY) {
      if (!currentBubble || currentBubble.moving || !isPlaying) return;

      const dx = targetX - SHOOTER_X;
      const dy = targetY - SHOOTER_Y;
      const angle = Math.atan2(dy, dx);
      // Clamp angle up (don't shoot downwards)
      const minAngle = (-Math.PI + 0.2);
      const maxAngle = (-0.2);
      const clamped = Math.max(minAngle, Math.min(maxAngle, angle));

      currentBubble.vx = Math.cos(clamped) * SHOOT_SPEED;
      currentBubble.vy = Math.sin(clamped) * SHOOT_SPEED;
      currentBubble.moving = true;
      isShooting = true;
      playShootSound();
    }

    function worldToGrid(x, y) {
      const r = Math.round((y - BUBBLE_RADIUS) / ROW_HEIGHT);
      const even = (r % 2 === 0);
      const offset = even ? 0 : BUBBLE_RADIUS;
      const c = Math.round((x - offset - BUBBLE_RADIUS) / (BUBBLE_RADIUS * 2));
      return { r, c };
    }

    function gridToWorld(r, c) {
      const even = (r % 2 === 0);
      const offset = even ? 0 : BUBBLE_RADIUS;
      const x = BUBBLE_RADIUS + offset + c * (BUBBLE_RADIUS * 2);
      const y = BUBBLE_RADIUS + r * ROW_HEIGHT;
      return { x, y };
    }

    function getNeighbors(r, c) {
      const neighbors = [];
      const even = (r % 2 === 0);
      const deltas = even
        ? [[-1,0],[-1,-1],[0,-1],[0,1],[1,0],[1,-1]]
        : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];
      for (const [dr, dc] of deltas) {
        const nr = r + dr;
        const nc = c + dc;
        if (grid[nr] && grid[nr][nc]) {
          neighbors.push(grid[nr][nc]);
        }
      }
      return neighbors;
    }

    function snapBubbleToGrid(bubble) {
      // clamp y to at least top row
      if (bubble.y < BUBBLE_RADIUS) {
        bubble.y = BUBBLE_RADIUS;
      }

      let { r, c } = worldToGrid(bubble.x, bubble.y);
      if (r < 0) r = 0;
      if (c < 0) c = 0;
      if (c >= COLS) c = COLS - 1;
      if (r >= grid.length) {
        // extend grid if needed
        for (let i = grid.length; i <= r; i++) {
          const row = new Array(COLS).fill(null);
          grid.push(row);
        }
      }
      // find nearest free neighbor if collision
      if (grid[r][c]) {
        // search around
        let best = { r, c };
        let bestDist = Infinity;
        for (let rr = r - 1; rr <= r + 1; rr++) {
          for (let cc = c - 1; cc <= c + 1; cc++) {
            if (!grid[rr] || cc < 0 || cc >= COLS) continue;
            if (grid[rr][cc]) continue;
            const { x, y } = gridToWorld(rr, cc);
            const d2 = (x - bubble.x) ** 2 + (y - bubble.y) ** 2;
            if (d2 < bestDist) {
              bestDist = d2;
              best = { r: rr, c: cc };
            }
          }
        }
        r = best.r;
        c = best.c;
      }
      const { x, y } = gridToWorld(r, c);
      bubble.x = x;
      bubble.y = y;
      bubble.r = r;
      bubble.c = c;
      if (!grid[r]) {
        const row = new Array(COLS).fill(null);
        grid[r] = row;
      }
      grid[r][c] = bubble;
    }

    function findCluster(startR, startC) {
      const target = grid[startR] && grid[startR][startC];
      if (!target) return [];
      const visited = new Set();
      const stack = [{ r: startR, c: startC }];
      const color = target.color;
      const cluster = [];

      while (stack.length) {
        const { r, c } = stack.pop();
        const key = r + ':' + c;
        if (visited.has(key)) continue;
        visited.add(key);
        const b = grid[r] && grid[r][c];
        if (!b || b.color !== color) continue;
        cluster.push(b);
        const even = (r % 2 === 0);
        const deltas = even
          ? [[-1,0],[-1,-1],[0,-1],[0,1],[1,0],[1,-1]]
          : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];
        for (const [dr, dc] of deltas) {
          const nr = r + dr;
          const nc = c + dc;
          if (!grid[nr]) continue;
          if (nc < 0 || nc >= COLS) continue;
          if (!grid[nr][nc]) continue;
          const nKey = nr + ':' + nc;
          if (!visited.has(nKey)) stack.push({ r: nr, c: nc });
        }
      }
      return cluster;
    }

    function removeFloating() {
      // Keep only bubbles connected to top rows
      const visited = new Set();
      const stack = [];

      // push all bubbles in row 0 & 1 as anchors
      for (let r = 0; r < Math.min(2, grid.length); r++) {
        for (let c = 0; c < COLS; c++) {
          const b = grid[r] && grid[r][c];
          if (b) stack.push({ r, c });
        }
      }

      while (stack.length) {
        const { r, c } = stack.pop();
        const key = r + ':' + c;
        if (visited.has(key)) continue;
        visited.add(key);
        const b = grid[r] && grid[r][c];
        if (!b) continue;
        const even = (r % 2 === 0);
        const deltas = even
          ? [[-1,0],[-1,-1],[0,-1],[0,1],[1,0],[1,-1]]
          : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];
        for (const [dr, dc] of deltas) {
          const nr = r + dr;
          const nc = c + dc;
          if (!grid[nr]) continue;
          if (nc < 0 || nc >= COLS) continue;
          if (!grid[nr][nc]) continue;
          const nKey = nr + ':' + nc;
          if (!visited.has(nKey)) stack.push({ r: nr, c: nc });
        }
      }

      let removed = 0;
      for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!grid[r]) continue;
          const b = grid[r][c];
          if (!b) continue;
          const key = r + ':' + c;
          if (!visited.has(key)) {
            // floating bubble
            grid[r][c] = null;
            removed++;
          }
        }
      }
      if (removed > 0) {
        addScore(removed * 5);
      }
    }

    function shiftRowsDown() {
      if (!grid.length) return;
      playWallShiftSound();
      // Add new row at top
      const newRowIndex = 0;
      const newRow = [];
      const offset = (newRowIndex % 2 === 0) ? 0 : 0.5;
      for (let c = 0; c < COLS; c++) {
        if (Math.random() < 0.85) {
          const x = (c + offset) * (BUBBLE_RADIUS * 2) + BUBBLE_RADIUS;
          const y = BUBBLE_RADIUS;
          newRow[c] = { r: 0, c, x, y, color: randomColor() };
        } else {
          newRow[c] = null;
        }
      }
      // Move all existing rows down
      for (let r = grid.length - 1; r >= 0; r--) {
        const row = grid[r];
        if (!row) continue;
        const nr = r + 1;
        if (!grid[nr]) grid[nr] = new Array(COLS).fill(null);
        for (let c = 0; c < COLS; c++) {
          const b = row[c];
          if (b) {
            b.r = nr;
            b.y += ROW_HEIGHT;
            grid[nr][c] = b;
          }
        }
      }
      grid[0] = newRow;

      // Danger check
      const dangerRow = MAX_ROWS_VISIBLE - 2;
      let maxRowUsed = 0;
      for (let r = grid.length - 1; r >= 0; r--) {
        let rowHas = false;
        for (let c = 0; c < COLS; c++) {
          if (grid[r] && grid[r][c]) {
            rowHas = true;
            break;
          }
        }
        if (rowHas) {
          maxRowUsed = r;
          break;
        }
      }
      if (maxRowUsed >= dangerRow) {
        setStatus('danger');
      }

      // Game over if any bubble crosses bottom limit
      const bottomLimit = H - 80;
      for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < COLS; c++) {
          const b = grid[r] && grid[r][c];
          if (!b) continue;
          if (b.y + BUBBLE_RADIUS >= bottomLimit) {
            triggerGameOver('The wall reached the safety line.');
            return;
          }
        }
      }
    }

    function addScore(points) {
      score += points;
      scoreEl.textContent = score;
      if (score > highScore) {
        highScore = score;
        highScoreEl.textContent = highScore;
        saveHighScore();
      }
    }

    function triggerGameOver(reason) {
      isGameOver = true;
      isPlaying = false;
      isShooting = false;
      setStatus('over');
      overlayTitleEl.textContent = 'GAME OVER';
      overlaySubtitleEl.textContent = reason || 'The bubble wall breached the safety line.';
      overlayScoreEl.textContent = score;
      overlayHighScoreEl.textContent = highScore;
      overlayEl.style.display = 'flex';
      playGameOverSound();
      btnStart.disabled = false;
      btnStart.innerHTML = '<span class="btn-icon">‚ñ∂</span> PLAY';
    }

    // ================== Rendering ==================
    function drawBackground() {
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, '#020617');
      g.addColorStop(0.4, '#020617');
      g.addColorStop(1, '#0b1120');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      // safety line
      ctx.strokeStyle = 'rgba(248,250,252,0.16)';
      ctx.lineWidth = 1;
      const y = H - 80;
      ctx.beginPath();
      ctx.moveTo(14, y + 0.5);
      ctx.lineTo(W - 14, y + 0.5);
      ctx.stroke();

      ctx.setLineDash([2,3]);
      ctx.strokeStyle = 'rgba(248,250,252,0.15)';
      ctx.beginPath();
      ctx.moveTo(14, y + 6);
      ctx.lineTo(W - 14, y + 6);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawBubble(x, y, color) {
      const rad = BUBBLE_RADIUS;
      const g = ctx.createRadialGradient(
        x - rad * 0.3, y - rad * 0.3, rad * 0.1,
        x, y, rad
      );
      g.addColorStop(0, '#ffffff');
      g.addColorStop(0.15, color);
      g.addColorStop(0.9, shadeColor(color, -25));
      g.addColorStop(1, 'rgba(15,23,42,0.95)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x, y, rad, 0, Math.PI * 2);
      ctx.fill();

      // highlight
      ctx.beginPath();
      ctx.arc(x - rad * 0.35, y - rad * 0.35, rad * 0.28, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.55)';
      ctx.fill();
    }

    function shadeColor(col, amt) {
      // col in #rrggbb
      let c = col.slice(1);
      const num = parseInt(c, 16);
      let r = (num >> 16) + amt;
      let g = ((num >> 8) & 0x00ff) + amt;
      let b = (num & 0x0000ff) + amt;
      r = Math.max(0, Math.min(255, r));
      g = Math.max(0, Math.min(255, g));
      b = Math.max(0, Math.min(255, b));
      return '#' + (r.toString(16).padStart(2, '0')
        + g.toString(16).padStart(2, '0')
        + b.toString(16).padStart(2, '0'));
    }

    function renderShooterBase() {
      // base
      ctx.save();
      ctx.translate(SHOOTER_X, SHOOTER_Y + 18);
      ctx.fillStyle = 'rgba(15,23,42,0.9)';
      ctx.strokeStyle = 'rgba(148,163,184,0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-36, 0);
      ctx.quadraticCurveTo(0, 14, 36, 0);
      ctx.quadraticCurveTo(0, 18, -36, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // glowing dots
      for (let i = -24; i <= 24; i += 12) {
        ctx.beginPath();
        ctx.arc(i, -4, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(34,197,94,0.8)';
        ctx.fill();
      }
      ctx.restore();
    }

    function renderShooterGuide() {
      if (!currentBubble) return;
      // aim line from shooter to bubble direction (if moving)
      let dx = currentBubble.x - SHOOTER_X;
      let dy = currentBubble.y - SHOOTER_Y;
      if (!currentBubble.moving) {
        dx = 0;
        dy = -1;
      }
      const angle = Math.atan2(dy, dx);
      const len = 80;
      const x2 = SHOOTER_X + Math.cos(angle) * len;
      const y2 = SHOOTER_Y + Math.sin(angle) * len;

      ctx.save();
      ctx.strokeStyle = 'rgba(56,189,248,0.65)';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(SHOOTER_X, SHOOTER_Y);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    function render() {
      drawBackground();

      // draw bubbles in grid
      for (let r = 0; r < grid.length; r++) {
        const row = grid[r];
        if (!row) continue;
        for (let c = 0; c < COLS; c++) {
          const b = row[c];
          if (!b) continue;
          drawBubble(b.x, b.y, b.color);
        }
      }

      // draw current bubble
      if (currentBubble) {
        drawBubble(currentBubble.x, currentBubble.y, currentBubble.color);
      }

      // show next color
      ctx.save();
      const x = W - 32;
      const y = SHOOTER_Y + 8;
      ctx.fillStyle = 'rgba(15,23,42,0.9)';
      ctx.strokeStyle = 'rgba(148,163,184,0.8)';
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.roundRect(x - 20, y - 16, 40, 32, 12);
      ctx.fill();
      ctx.stroke();
      drawBubble(x, y, nextColor);
      ctx.restore();

      renderShooterBase();
      renderShooterGuide();
    }

    // ================== Update Loop ==================
    function update(dt) {
      if (!isPlaying) {
        render();
        return;
      }

      // move bubble if shooting
      if (currentBubble && currentBubble.moving) {
        currentBubble.x += currentBubble.vx * dt;
        currentBubble.y += currentBubble.vy * dt;

        // bounce off walls
        if (currentBubble.x <= BUBBLE_RADIUS) {
          currentBubble.x = BUBBLE_RADIUS;
          currentBubble.vx *= -1;
        } else if (currentBubble.x >= W - BUBBLE_RADIUS) {
          currentBubble.x = W - BUBBLE_RADIUS;
          currentBubble.vx *= -1;
        }

        // ceiling collision
        if (currentBubble.y <= BUBBLE_RADIUS + 1) {
          currentBubble.y = BUBBLE_RADIUS + 1;
          placeAndResolve();
        } else {
          // collision with other bubbles
          let collided = false;
          outer: for (let r = 0; r < grid.length; r++) {
            const row = grid[r];
            if (!row) continue;
            for (let c = 0; c < COLS; c++) {
              const b = row[c];
              if (!b) continue;
              const dx = b.x - currentBubble.x;
              const dy = b.y - currentBubble.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < BUBBLE_RADIUS * 2 - 1) {
                collided = true;
                break outer;
              }
            }
          }
          if (collided) {
            placeAndResolve();
          }
        }
      }

      render();
    }

    function placeAndResolve() {
      if (!currentBubble) return;
      currentBubble.moving = false;
      snapBubbleToGrid(currentBubble);

      const r = currentBubble.r;
      const c = currentBubble.c;
      const cluster = findCluster(r, c);
      let popped = 0;

      if (cluster.length >= 3) {
        for (const b of cluster) {
          if (grid[b.r] && grid[b.r][b.c]) {
            grid[b.r][b.c] = null;
            popped++;
          }
        }
        addScore(popped * 10);
        playPopSound();
        removeFloating();
      }

      currentBubble = null;
      createCurrentBubble();

      shotsSinceShift++;
      if (shotsSinceShift >= 6) {
        shotsSinceShift = 0;
        shiftRowsDown();
      }

      isShooting = false;
      // If grid empty ‚Üí win
      let any = false;
      for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < COLS; c++) {
          if (grid[r] && grid[r][c]) {
            any = true;
            break;
          }
        }
        if (any) break;
      }
      if (!any) {
        overlayTitleEl.textContent = 'YOU WIN';
        overlaySubtitleEl.textContent = 'You cleared every single bubble. Ultra clutch!';
        overlayScoreEl.textContent = score;
        overlayHighScoreEl.textContent = highScore;
        overlayEl.style.display = 'flex';
        isPlaying = false;
        setStatus('ready');
      }
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min(0.04, (timestamp - lastTime) / 1000);
      lastTime = timestamp;
      update(dt);
      requestAnimationFrame(loop);
    }

    // ================== Input ==================
    function canvasPosFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches.length) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      const x = ((clientX - rect.left) / rect.width) * canvas.width;
      const y = ((clientY - rect.top) / rect.height) * canvas.height;
      return { x, y };
    }

    function handlePointerDown(e) {
      e.preventDefault();
      if (!isPlaying || isGameOver) return;
      const { x, y } = canvasPosFromEvent(e);
      startShot(x, y);
    }

    canvas.addEventListener('mousedown', handlePointerDown);
    canvas.addEventListener('touchstart', handlePointerDown, { passive: false });

    // ================== Buttons ==================
    function startGame() {
      isGameOver = false;
      overlayEl.style.display = 'none';
      score = 0;
      scoreEl.textContent = '0';
      shotsSinceShift = 0;
      setStatus('playing');
      resetGrid();
      createCurrentBubble();
      isPlaying = true;
      btnStart.disabled = true;
      btnStart.innerHTML = '<span class="btn-icon">‚è∏</span> RUNNING';
    }

    function resetAndStart() {
      startGame();
    }

    btnStart.addEventListener('click', () => {
      if (!isPlaying || isGameOver) {
        resetAndStart();
      }
    });

    btnTryAgain.addEventListener('click', () => {
      resetAndStart();
    });

    btnMute.addEventListener('click', () => {
      muted = !muted;
      if (muted) {
        btnMute.innerHTML = '<span class="btn-icon">üîà</span> MUTED';
        btnMute.classList.add('on');
      } else {
        btnMute.innerHTML = '<span class="btn-icon">üîä</span> SOUND';
        btnMute.classList.remove('on');
      }
    });

    // ================== Init ==================
    loadHighScore();
    setStatus('ready');
    resetGrid();
    createCurrentBubble();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
